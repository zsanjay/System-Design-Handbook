
## How to store passwords safely in the database and how to validate a password?


![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42fa9ae2-5e7d-4787-b293-8e229c70d8a9_2343x2436.png)


**Things Not to do**

üîπ Storing passwords in plain text is not a good idea because anyone with internal access can see them.

üîπ Storing password hashes directly is not sufficient because it is pruned to precomputation attacks, such as rainbow tables.¬†

üîπ To mitigate precomputation attacks, we salt the passwords.¬†

**What is salt?**

According to OWASP guidelines, ‚Äúa salt is a unique, randomly generated string that is added to each password as part of the hashing process‚Äù.

**How to store a password and salt?**

1Ô∏è‚É£ A salt is not meant to be secret and it can be stored in plain text in the database. It is used to ensure the hash result is unique to each password.

2Ô∏è‚É£¬† The password can be stored in the database using the following format:¬†_hash(password + salt)_

**How to validate a password?**

To validate a password, it can go through the following process:

1Ô∏è‚É£ A client enters the password.

2Ô∏è‚É£ The system fetches the corresponding salt from the database.

3Ô∏è‚É£ The system appends the salt to the password and hashes it. Let‚Äôs call the hashed value H1.

4Ô∏è‚É£ The system compares H1 and H2, where H2 is the hash stored in the database. If they are the same, the password is valid.¬†

### What other mechanisms can we use to ensure password safety?


### 1. **Strong Password Policies**

- **Length**: Passwords should be at least 12 characters long. The longer the password, the harder it is to crack using brute force attacks.
- **Complexity**: Require a mix of:
    - Uppercase letters
    - Lowercase letters
    - Numbers
    - Special characters (e.g., `!@#&$`)
- **Avoid Common Passwords**: Implement checks to prevent common or easily guessable passwords, like `password123`, `qwerty`, etc.
- **Prohibit Password Reuse**: Encourage or enforce a policy that users cannot reuse passwords across accounts or systems.

### 2. **Password Hashing and Salting**

- **Hashing**: When storing passwords, **never store passwords in plain text**. Use a secure cryptographic hash function like **bcrypt**, **scrypt**, or **Argon2**. These algorithms are designed to be computationally expensive, slowing down brute force attacks.
- **Salting**: Add a unique salt to each password before hashing it. This ensures that even if two users have the same password, their stored hashes will be different. A salt is a random string that is concatenated with the password before hashing.
- **Pepper**: Optionally, you can also use a pepper, which is another random value added to the password, and it is kept secret from the database (e.g., stored in application code or environment variables).

### 3. **Multi-Factor Authentication (MFA)**

- **Something you know (Password)**: The traditional password.
- **Something you have (Hardware Token or OTP)**: A one-time password (OTP) generated by an authenticator app (e.g., Google Authenticator, Authy), or a hardware token like a YubiKey.
- **Something you are (Biometrics)**: Fingerprint or facial recognition.

**MFA** is one of the most effective ways to improve security by requiring more than just a password. Even if an attacker has compromised a password, they would still need the second factor.

### 4. **Rate Limiting and Account Lockout**

- **Rate Limiting**: Limit the number of failed login attempts from the same IP address or account within a specific time window (e.g., five failed attempts in 10 minutes). This reduces the risk of brute force attacks.
- **Account Lockout**: After a certain number of failed login attempts, temporarily lock the account for a set period or require the user to go through additional verification steps (e.g., email or phone number verification).

### 5. **Password Managers**

- Encourage users to use **password managers** like LastPass, 1Password, or Bitwarden to generate and store complex, unique passwords for each service they use. This removes the temptation to use simple or repeated passwords.
- Password managers also help ensure that users are not entering passwords on malicious or phishing sites.

### 6. **Regular Password Expiry (Optional)**

- Some systems enforce periodic password changes (e.g., every 90 days). However, this practice is now considered less critical if other mechanisms like MFA and strong passwords are in place.
- **Caution**: Regular forced password changes can sometimes encourage users to create weaker passwords (e.g., simple variations of old passwords). Ensure any password change policy doesn‚Äôt undermine security by requiring users to pick weak or reused passwords.

### 7. **Secure Transmission (HTTPS)**

- Always use **HTTPS** (SSL/TLS) for transmitting passwords over the network. Passwords should never be transmitted over HTTP because it is not encrypted, which makes it vulnerable to man-in-the-middle (MITM) attacks.
- Ensure that cookies storing session information or tokens are marked as **Secure** and **HttpOnly**, making them less vulnerable to cross-site scripting (XSS) attacks.

### 8. **Preventing Phishing**

- **User Education**: Educate users to recognize phishing attempts and avoid entering passwords into untrusted websites or emails.
- **Phishing Detection**: Implement anti-phishing mechanisms, such as checking URLs or using trusted certificate authorities (CAs) to prevent users from visiting fraudulent sites.
- **Email Verification for Login Attempts**: Alert users about login attempts or password changes via email, which helps them spot unauthorized access quickly.

### 9. **Password Expiry Notifications and Recovery**

- **Expiration Notifications**: If your system requires password expiration, ensure users are notified before their password expires and given an easy way to update it.
- **Password Recovery**: Implement a secure password recovery process (e.g., email-based or via a trusted app), ensuring that it includes multi-step verification to prevent unauthorized password resets.

### 10. **Avoiding Storing Plaintext Passwords**

- **Never store passwords in plaintext**: Always hash and salt passwords before storing them in your database.
- If possible, use **zero-knowledge protocols** where even the service provider cannot see the password.

### 11. **Session Management**

- **Session Expiry**: Sessions should automatically expire after a reasonable period of inactivity (e.g., 15 minutes).
- **Re-authentication**: For sensitive actions (e.g., account deletion, financial transactions), prompt the user to re-enter their password or use an additional layer of authentication.
- **Refresh Tokens**: Use short-lived access tokens with refresh tokens to ensure that users are re-authenticated regularly, reducing the impact of token theft.

### 12. **Zero Trust Architecture**

- In highly sensitive environments, adopting a **Zero Trust** security model is beneficial. This model assumes that both internal and external networks could be compromised and requires continuous verification of identity and trust for every access request.
- In the context of passwords, this could involve verifying a user's identity using multiple factors even when they are already authenticated.

### 13. **Passwordless Authentication (FIDO2, WebAuthn)**

- **Passwordless authentication** allows users to authenticate without needing a password. This can be done through biometric authentication (fingerprint, face recognition), hardware security keys (like YubiKeys), or magic links sent via email.
- Technologies like **FIDO2** and **WebAuthn** make passwordless authentication more secure and user-friendly by eliminating passwords altogether and relying on cryptographic keys instead.

### 14. **Security Auditing and Logging**

- Regularly audit password-related operations like password changes, login attempts, and account lockouts. Maintain detailed logs to detect any suspicious activity.
- Use **Security Information and Event Management (SIEM)** tools to monitor and analyze logs for potential breaches or anomalies.

---

### Key Takeaways:

- **Strong Passwords**: Length, complexity, and uniqueness are essential.
- **Multi-Factor Authentication (MFA)**: This is one of the most effective ways to secure your systems, even if passwords are compromised.
- **Hashing and Salting**: Never store passwords in plaintext; use a cryptographic hash function.
- **Password Managers**: Encourage users to use them for storing and generating secure passwords.
- **Secure Transmission**: Always use HTTPS to prevent password interception.