
1. Client-Server Architecture  
→ The base of every web app. Your phone/browser talks to a server.  
  
2. IP Address & DNS  
→ How clients find servers. DNS maps site names to server addresses.  
  
3. Proxy & Reverse Proxy  
→ Used to hide identity, balance load, and handle routing smartly.  
  
4. Latency  
→ Delay in data travel. Affects app speed, especially across countries.  
  
5. HTTP vs HTTPS  
→ How the internet talks. HTTPS adds encryption (TLS/SSL).  
  
6. APIs & REST  
→ Bridge between client and server. REST is the most common style.  
  
7. Concurrency  
→ Running multiple tasks at the same time. Key to scaling systems and improving performance.  
  
8. SQL vs NoSQL  
→ SQL = structured, consistent (banks). NoSQL = flexible, scalable (big data apps).  
  
9. Vertical Scaling  
→ Add more power to one machine.  
  
10. Horizontal Scaling  
→ Add more machines. More reliable and scalable.  
  
11. Load Balancer  
→ Decides which server should handle a request. Keeps things running smooth.  
  
12. Indexing  
→ Speeds up database reads, like a book’s index.  
  
13. Replication  
→ Makes read-only copies of databases to handle more traffic.  
  
14. Sharding  
→ Splits data across machines based on keys (like user ID).  
  
15. Vertical Partitioning  
→ Split tables by columns to avoid unnecessary data scanning.  
  
16. Caching  
→ Store frequently used data in memory for faster access.  
  
17. Denormalization  
→ Combine tables to avoid slow JOINs. Used in read-heavy systems.  
  
18. CAP Theorem  
→ You can only have 2 out of 3: Consistency, Availability, Partition tolerance.  
  
19. Blob Storage (e.g., S3)  
→ For storing images, PDFs, videos, and large files.  
  
20. CDN  
→ Delivers content from the nearest location. Speeds up load times globally.  
  
21. WebSockets  
→ Real-time updates. Used in chat apps, stock dashboards, and games.  
  
22. Webhooks  
→ Push updates between services instantly (e.g., payment confirmations).  
  
23. Microservices  
→ Break big apps into small, independent services. Easier to manage.  
  
24. Message Queues  
→ Let services talk without waiting. Improves scalability.  
  
25. Rate Limiting & API Gateway  
→ Protects your services from overload and abuse.